<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>RTTY Art WAV Builder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#0e0f12; --panel:#16181d; --ink:#e6e7eb; --muted:#9aa0a6; --accent:#7aa2ff; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial; background:var(--bg); color:var(--ink); }
    header { padding:16px 20px; border-bottom:1px solid #222833; background:linear-gradient(180deg,#12141a,#0e0f12); position:sticky; top:0; }
    h1 { margin:0; font-size:20px; letter-spacing:.3px; }
    .wrap { padding:12px; display:grid; grid-template-columns: 420px 1fr; gap:12px; }
    @media (max-width: 980px){ .wrap{ grid-template-columns: 1fr; } }
    .card { background:var(--panel); border:1px solid #222833; border-radius:14px; padding:12px; }
    label { display:block; font-size:12px; color:var(--muted); margin-bottom:4px; }
    input[type="number"], input[type="text"], select { width:100%; padding:10px 12px; border-radius:10px; border:1px solid #2a3040; background:#0f1116; color:var(--ink); }
    button { padding:10px 12px; border-radius:10px; border:1px solid #2a3040; background:#0f1116; color:var(--ink); cursor:pointer; }
    button.primary { background:var(--accent); color:#0b0c10; border-color:#2c3e89; font-weight:600; }
    button:disabled { opacity:.6; cursor:not-allowed; }
    .row { display:grid; grid-template-columns: 1fr 1fr; gap:8px; margin-bottom:8px; }
    .row3 { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:8px; margin-bottom:8px; }
    .status { color:var(--muted); font-size:12px; margin-top:6px; min-height:18px; }
    .list { max-height:48vh; overflow:auto; border-top:1px dashed #2a3040; margin-top:8px; padding-top:8px; }
    audio { width:100%; margin-top:10px; }
    .muted { color:var(--muted); }
    .inline { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    pre.testlog { background:#0b0c10; color:#c4d2ff; padding:10px; border-radius:10px; border:1px dashed #2a3040; max-height:32vh; overflow:auto; }
    .links a{ display:inline-block; margin:6px 8px 0 0; }
  </style>
</head>
<body>
  <header>
    <h1>RTTY Art WAV Builder</h1>
  </header>

  <div class="wrap">
    <div class="card">
      <div class="row">
        <div>
          <label>Data source</label>
          <select id="dataSource">
            <option value="remote" selected>Remote (textfiles proxy)</option>
            <option value="bundled">Bundled (manifest in repo)</option>
          </select>
        </div>
        <div>
          <label>Count (artworks)</label>
          <input id="count" type="number" value="25" min="1" max="500" />
        </div>
      </div>

      <div id="bundledControls" class="inline" style="display:none">
        <div style="flex:1 1 260px; min-width:240px;">
          <label>Manifest URL (relative)</label>
          <input id="manifestUrl" type="text" value="rtty_offline/manifest.json" />
        </div>
        <div>
          <label>&nbsp;</label>
          <button id="loadManifestBtn">Load manifest</button>
        </div>
        <div class="muted" id="manifestStatus">not loaded</div>
      </div>

      <div class="row" style="margin-top:8px;">
        <div>
          <label>Baud Rate</label>
          <input id="baudRate" type="number" value="45.45" step="0.01" />
        </div>
        <div>
          <label>Stop Bits</label>
          <input id="stopBits" type="number" value="1.5" step="0.1" />
        </div>
      </div>
      <div class="row">
        <div>
          <label>Mark Frequency (Hz)</label>
          <input id="markFreq" type="number" value="2125" />
        </div>
        <div>
          <label>Space Frequency (Hz)</label>
          <input id="spaceFreq" type="number" value="2295" />
        </div>
      </div>
      <div class="row">
        <div>
          <label>Gap between pieces (sec)</label>
          <input id="gap" type="number" value="2" min="0" step="0.1" />
        </div>
        <div>
          <label>&nbsp;</label>
          <button id="buildBtn" class="primary" style="width:100%">Build WAV</button>
        </div>
      </div>

      <div class="row">
        <div>
          <label>Max minutes / item (0 = no limit, may split mid‑piece)</label>
          <input id="maxMinItem" type="number" value="0" min="0" step="0.5" />
        </div>
        <div>
          <label>Max minutes total (stops run when reached)</label>
          <input id="maxMinTotal" type="number" value="60" min="1" step="1" />
        </div>
      </div>

      <div class="row">
        <div>
          <label>Split every (minutes per file)</label>
          <input id="splitMin" type="number" value="30" min="1" step="1" />
        </div>
        <div>
          <label>&nbsp;</label>
          <div class="muted">Large jobs become multiple WAVs; first one loads in the player.</div>
        </div>
      </div>

      <div id="status" class="status">idle</div>
      <audio id="player" controls></audio>
      <div id="downloadWrap" class="status links"></div>

      <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
        <button id="testBtn">Run self-test</button>
        <span class="muted">(verifies Baudot, AFSK, and WAV header)</span>
      </div>
      <pre id="testLog" class="testlog" style="display:none"></pre>
    </div>

    <div class="card">
      <div><b>Selected items</b> <span class="muted" id="countInfo"></span></div>
      <ol id="list" class="list"></ol>
    </div>
  </div>

<script>
(() => {
  'use strict';

  // ====== Surface runtime errors in the status line ======
  window.addEventListener('error', (e) => {
    const el = document.getElementById('status');
    if (el) el.textContent = 'JS error: ' + (e.message || (e.error && e.error.message) || e);
  });
  window.addEventListener('unhandledrejection', (e) => {
    const el = document.getElementById('status');
    if (el) el.textContent = 'Promise error: ' + (e.reason && (e.reason.message||e.reason));
  });

  // ====== Remote source (CORS-safe via proxies) ======
  const ORIGIN = "https://artscene.textfiles.com/rtty/COLLECTION/";
  const FIXED_DIRS = Array.from({length:8}, (_,i)=>`ARTWORK-0${i+1}/`);
  const PROXIES = [
    "https://r.jina.ai/https://artscene.textfiles.com/rtty/COLLECTION/",
    "https://r.jina.ai/http://artscene.textfiles.com/rtty/COLLECTION/"
  ];
  async function fetchFromAny(path=""){
    let lastErr;
    for (const base of PROXIES){
      try{
        const r = await fetch(base + path, { cache:"reload" });
        if (!r.ok) continue;
        return await r.text();
      }catch(e){ lastErr = e; }
    }
    throw lastErr || new Error("fetch failed");
  }

  // ====== UI ======
  const els = {
    buildBtn: document.getElementById('buildBtn'),
    status: document.getElementById('status'),
    player: document.getElementById('player'),
    list: document.getElementById('list'),
    countInfo: document.getElementById('countInfo'),
    downloadWrap: document.getElementById('downloadWrap'),
    baud: document.getElementById('baudRate'),
    stopBits: document.getElementById('stopBits'),
    mark: document.getElementById('markFreq'),
    space: document.getElementById('spaceFreq'),
    count: document.getElementById('count'),
    gap: document.getElementById('gap'),
    testBtn: document.getElementById('testBtn'),
    testLog: document.getElementById('testLog'),
    dataSource: document.getElementById('dataSource'),
    bundledControls: document.getElementById('bundledControls'),
    manifestUrl: document.getElementById('manifestUrl'),
    loadManifestBtn: document.getElementById('loadManifestBtn'),
    manifestStatus: document.getElementById('manifestStatus'),
    maxMinItem: document.getElementById('maxMinItem'),
    maxMinTotal: document.getElementById('maxMinTotal'),
    splitMin: document.getElementById('splitMin'),
  };
  const setStatus = s => els.status.textContent = s;

  // ====== Bundled state ======
  const bundled = { base:"", items:[], loaded:false };

  function toggleBundledUI(){
    const mode = els.dataSource.value;
    els.bundledControls.style.display = (mode === 'bundled') ? 'flex' : 'none';
  }
  toggleBundledUI();
  els.dataSource.addEventListener('change', toggleBundledUI);

  function deriveBaseFromUrl(url){
    const slash = url.lastIndexOf('/');
    return slash >= 0 ? url.slice(0, slash) : '';
  }

  async function loadManifest(){
    try{
      els.manifestStatus.textContent = 'loading…';
      const url = els.manifestUrl.value.trim();
      const res = await fetch(url, { cache:'no-cache' });
      if (!res.ok) throw new Error('HTTP '+res.status);
      const json = await res.json();
      let base="", items=[];
      if (Array.isArray(json)){
        items = json.slice();
        base = deriveBaseFromUrl(url);
      } else if (json && Array.isArray(json.items)){
        items = json.items.slice();
        base = (json.base || '').trim() || deriveBaseFromUrl(url);
      } else {
        for (const [dir, arr] of Object.entries(json||{})){
          if (Array.isArray(arr)){
            for (const f of arr){ items.push(`${dir}/${f}`); }
          }
        }
        base = (json.base || '').trim() || deriveBaseFromUrl(url);
      }
      items = items.filter(x => /^(ARTWORK-0[1-8])\/([0-9]{3})$/.test(x));
      if (!items.length) throw new Error('manifest had no valid items');
      bundled.base = base; bundled.items = items; bundled.loaded = true;
      els.manifestStatus.textContent = `loaded ${items.length} items from ${base||'(root)'}`;
      return true;
    }catch(e){
      bundled.base = ""; bundled.items = []; bundled.loaded = false;
      els.manifestStatus.textContent = 'load failed: ' + (e.message||e);
      return false;
    }
  }
  els.loadManifestBtn.addEventListener('click', loadManifest);

  // ====== CR/LF constants + helpers to avoid escape confusion ======
  const CR = String.fromCharCode(13);
  const LF = String.fromCharCode(10);
  function normalizeCRLF(s){
    // Replace bare CR with CRLF; leave existing CRLF intact.
    const re = new RegExp(CR + '(?!' + LF + ')', 'g');
    return (s || '').replace(re, CR + LF);
  }

  // ====== Remote directory & file discovery ======
  async function getDirs(){
    try{
      const html = await fetchFromAny("");
      const doc = new DOMParser().parseFromString(html, "text/html");
      let dirs = [...doc.querySelectorAll('a[href]')]
        .map(a=>a.getAttribute('href')||"")
        .map(h=> h.endsWith('/') ? h : h + '/')
        .filter(h=> /^ARTWORK-[0-9]+\/$/.test(h))
        .filter(d=> /^ARTWORK-0[1-8]\//.test(d));
      return dirs.length ? dirs : FIXED_DIRS.slice();
    } catch { return FIXED_DIRS.slice(); }
  }

  const dirCache = new Map();
  async function getFiles(dir){
    if (dirCache.has(dir)) return dirCache.get(dir);
    try{
      const html = await fetchFromAny(dir);
      const doc = new DOMParser().parseFromString(html, "text/html");
      const files = [...doc.querySelectorAll('a[href]')]
        .map(a=>({name:(a.textContent||"").trim(), href:a.getAttribute('href')||""}))
        .filter(o=> /^[0-9]+$/.test(o.name) || /^[0-9]+\/?$/.test(o.href))
        .map(o=> o.name.endsWith('/') ? o.name.slice(0,-1) : o.name);
      if (files.length){ dirCache.set(dir, files); return files; }
    }catch{}
    const probe = []; for (let i=0; i<=200; i++) probe.push(i.toString().padStart(3,'0'));
    dirCache.set(dir, probe); return probe;
  }

  async function fetchArtTextRemote(path){
    try{
      const html = await fetchFromAny(path);
      const doc = new DOMParser().parseFromString(html, "text/html");
      const pre = doc.querySelector('pre');
      let text = pre ? (pre.textContent||"") : (doc.body ? doc.body.textContent : html);
      return normalizeCRLF(text);
    }catch{ return ""; }
  }

  async function fetchArtTextBundled(rel){
    try{
      const url = (bundled.base ? (bundled.base + '/') : '') + rel;
      const r = await fetch(url, { cache:'no-cache' });
      if (!r.ok) return "";
      const txt = await r.text();
      return normalizeCRLF(txt);
    }catch{ return ""; }
  }

  async function sampleRandomArt(n){
    if (els.dataSource.value === 'bundled'){
      if (!bundled.loaded){
        const ok = await loadManifest();
        if (!ok) return [];
      }
      const seen = new Set();
      const out = []; let attempts=0, maxAttempts=n*20;
      while (out.length<n && attempts++<maxAttempts){
        const item = bundled.items[Math.floor(Math.random()*bundled.items.length)];
        if (seen.has(item)) continue; seen.add(item);
        const [dir, file] = item.split('/');
        out.push({ dir, filename:file, pagePath:item, originUrl:item });
      }
      return out;
    }
    // Remote
    const dirs = await getDirs();
    const chosen = []; const seen = new Set();
    let attempts = 0, maxAttempts = n * 40;
    while (chosen.length < n && attempts++ < maxAttempts){
      const dir = dirs[Math.floor(Math.random()*dirs.length)];
      const files = await getFiles(dir);
      if (!files.length) continue;
      const fn = files[Math.floor(Math.random()*files.length)];
      const key = dir+fn; if (seen.has(key)) continue; seen.add(key);
      const cleanDir = dir.endsWith('/') ? dir.slice(0,-1) : dir;
      chosen.push({ dir: cleanDir, filename: fn, pagePath: dir + fn, originUrl: ORIGIN + dir + fn });
    }
    let idx = 0;
    while (chosen.length < n){
      for (const dir of dirs){
        const num = (idx++).toString().padStart(3,'0');
        const key = dir+num; if (seen.has(key)) continue; seen.add(key);
        const cleanDir = dir.endsWith('/') ? dir.slice(0,-1) : dir;
        chosen.push({ dir: cleanDir, filename: num, pagePath: dir + num, originUrl: ORIGIN + dir + num });
        if (chosen.length >= n) break;
      }
    }
    return chosen.slice(0, n);
  }

  // ====== BAUDOT / AFSK ======
  const printableSet = "#ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789:;.,-'()/&$?! ";
  const replacementMap = {
    '\"':"'", '=':'-', '*':'X', '_':'-', '@':'A', '%':'O',
    '[':'(', ']':')', '{':'(', '}':')', [String.fromCharCode(92)]:'/', '^':'-', '|':'/',
    '`':"'", '~':'-', '<':'(', '>':')'
  };
  const normalizeChar = ch => {
    if (ch === CR || ch === LF) return ch; // keep CR/LF
    const u = ch.toUpperCase();
    const safe = replacementMap[u] || replacementMap[ch] || u;
    return printableSet.includes(safe) ? safe : ' ';
  };
  const normalizeText = s => [...s].map(normalizeChar).join('');

  const LTRS = 0b11111, FIGS = 0b11011;
  const BAUDOT_TABLE = {
    LTRS: {
      'A':0b00011,'B':0b11001,'C':0b01110,'D':0b01001,'E':0b00001,'F':0b01101,'G':0b11010,'H':0b10100,
      'I':0b00110,'J':0b01011,'K':0b01111,'L':0b10010,'M':0b11100,'N':0b01100,'O':0b11000,'P':0b10110,
      'Q':0b10111,'R':0b01010,'S':0b00101,'T':0b10000,'U':0b00111,'V':0b11110,'W':0b10011,'X':0b11101,
      'Y':0b10101,'Z':0b10001,[CR]:0b01000,[LF]:0b00010,' ':0b00100
    },
    FIGS: {
      '-':0b00011,'?':0b11001,':':0b01110,'$':0b01001,'3':0b00001,'!':0b01101,'&':0b11010,'#':0b10100,
      '8':0b00110,"'":0b01011,'(':0b01111,')':0b10010,'.':0b11100,',':0b01100,'9':0b11000,'0':0b10110,
      '1':0b10111,'4':0b01010,'Bell':0b00101,'5':0b10000,'7':0b00111,';':0b11110,'2':0b10011,'/':0b11101,
      '6':0b10101,'+':0b10001,[CR]:0b01000,[LF]:0b00010,' ':0b00100
    }
  };

  const DEFAULT_STRETCH = 1.002;

  // Streamed AFSK generator -> Int16 chunks
  function afskStream(frames, opts, onChunk){
    const { baud, mark, space, stopBits, sampleRate, stretch = DEFAULT_STRETCH } = opts;
    const twoPi = 2*Math.PI; const spbF = (sampleRate/baud)*stretch; let carry=0, phase=0;
    const BLOCK = 16384; let block = new Int16Array(BLOCK); let bi = 0; let total = 0;
    const pushSample = (s) => {
      block[bi++] = s;
      if (bi === block.length){ onChunk(block); block = new Int16Array(BLOCK); bi = 0; }
      total++;
    };
    const flush = () => { if (bi>0){ onChunk(block.slice(0,bi)); bi = 0; } };
    const emit = (freq, bitUnits) => {
      let want = Math.floor(spbF*bitUnits + carry); carry = spbF*bitUnits + carry - want;
      const inc = twoPi*freq/sampleRate;
      for (let i=0;i<want;i++){
        const f = Math.sin(phase); phase += inc; if (phase>=twoPi) phase -= twoPi;
        const s = (f<=1? (f>=-1? f : -1) : 1) * 32767;
        pushSample(s|0);
      }
    };
    for (const f of frames){
      if (f.type==='hold'){ emit(mark, (f.sec||0)*baud); continue; }
      if (f.type==='char'){
        const code=f.code & 0x1F; emit(space,1); for (let i=0;i<5;i++){ const bit=(code>>i)&1; emit(bit?mark:space,1);} emit(mark, stopBits); if (f.guardBits&&f.guardBits>0) emit(mark, f.guardBits);
      }
    }
    emit(mark,2.0);
    flush();
    return total;
  }

  // WAV header builder (16-bit PCM mono)
  function makeWavHeader(sampleRate, sampleCount){
    const dataBytes = sampleCount * 2 >>> 0; // modulo 2^32 per RIFF
    const riffSize = (36 + dataBytes) >>> 0;
    const buffer = new ArrayBuffer(44); const view = new DataView(buffer);
    const putStr=(o,s)=>{ for(let i=0;i<s.length;i++) view.setUint8(o+i, s.charCodeAt(i)); };
    putStr(0,'RIFF'); view.setUint32(4, riffSize, true);
    putStr(8,'WAVE'); putStr(12,'fmt '); view.setUint32(16,16,true);
    view.setUint16(20,1,true); view.setUint16(22,1,true);
    view.setUint32(24,sampleRate,true); view.setUint32(28,sampleRate*2,true);
    view.setUint16(32,2,true); view.setUint16(34,16,true);
    putStr(36,'data'); view.setUint32(40, dataBytes, true);
    return buffer;
  }

  // ====== Build many WAVs (splitting by minutes / WAV limit) ======
  els.buildBtn.addEventListener('click', async () => {
    try{
      els.buildBtn.disabled = true; els.downloadWrap.innerHTML = ''; els.player.src = '';
      const n = Math.max(1, Math.min(500, parseInt(els.count.value||"25",10)));
      const gapSec = Math.max(0, parseFloat(els.gap.value||"2"));

      setStatus('Sampling artwork…');
      const picks = await sampleRandomArt(n);
      if (!picks.length){ setStatus('No items to process'); return; }

      // Render list
      els.list.innerHTML = picks.map(p=>{
        const href = (els.dataSource.value==='bundled' && bundled.base) ? `${bundled.base}/${p.pagePath}` : (p.originUrl||p.pagePath);
        return `<li><a href="${href}" target="_blank" rel="noopener">${p.dir}/${p.filename}</a></li>`;
      }).join('');
      els.countInfo.textContent = `(${picks.length})`;

      // Params
      const baud  = parseFloat(els.baud.value||"45.45");
      const stopB = parseFloat(els.stopBits.value||"1.5");
      const mark  = parseFloat(els.mark.value||"2125");
      const space = parseFloat(els.space.value||"2295");
      const sr = getSampleRate();

      const maxItemMin = Math.max(0, parseFloat(els.maxMinItem.value||"0"));
      const maxTotalMin = Math.max(1, parseFloat(els.maxMinTotal.value||"60"));
      const splitMin = Math.max(1, parseFloat(els.splitMin.value||"30"));

      const PER_ITEM_LIMIT = maxItemMin>0 ? Math.floor(sr*60*maxItemMin) : Number.POSITIVE_INFINITY;
      const OVERALL_LIMIT  = Math.floor(sr*60*maxTotalMin);
      const WAV_BYTES_LIMIT = 0xFFFFFFFF - 8; // safety
      const SEG_LIMIT_BY_SPLIT = Math.floor(sr*60*splitMin);
      const SEG_LIMIT_BY_WAV = Math.floor(WAV_BYTES_LIMIT/2);
      const SEG_LIMIT = Math.min(SEG_LIMIT_BY_SPLIT, SEG_LIMIT_BY_WAV);

      // Diagnostics
      const stats = { empties:0, estZero:0, tooLongSkipped:0, tooLongStreamed:0, stoppedOverall:false, segments:0 };

      // Segment accumulators
      let segChunks = []; // Uint8Array pieces (PCM)
      let segSamples = 0; let segIndex = 1; let overallSamples = 0;
      const openNewSegment = () => { segChunks = []; segSamples = 0; };
      const flushSegment = () => {
        if (segSamples <= 0) return null;
        const header = makeWavHeader(sr, segSamples);
        const blob = new Blob([header, ...segChunks], { type:'audio/wav' });
        const url = URL.createObjectURL(blob);
        const minutes = (segSamples/sr)/60;
        const a = document.createElement('a');
        a.href = url; a.download = `rtty_art_seg${String(segIndex).padStart(2,'0')}.wav`;
        a.textContent = `Download WAV (seg ${segIndex}, ~${minutes.toFixed(1)} min)`;
        els.downloadWrap.appendChild(a);
        stats.segments++;
        if (segIndex === 1){ els.player.src = url; els.player.load(); }
        segIndex++;
        return url;
      };
      openNewSegment();

      // segment-safe sink
      const pushPCM = (int16Arr) => {
        let off = 0;
        while (off < int16Arr.length){
          const room = SEG_LIMIT - segSamples;
          if (room <= 0){ flushSegment(); openNewSegment(); continue; }
          const take = Math.min(room, int16Arr.length - off);
          const view = new Uint8Array(int16Arr.buffer, int16Arr.byteOffset + off*2, take*2);
          // copy to detach from backing buffer
          const copy = new Uint8Array(take*2); copy.set(view);
          segChunks.push(copy);
          segSamples += take; overallSamples += take; off += take;
          if (overallSamples >= OVERALL_LIMIT){ stats.stoppedOverall = true; return false; }
        }
        return true;
      };

      const emitSilence = async(samples) => {
        const BLOCK = 16384;
        while (samples > 0){
          const take = Math.min(samples, BLOCK);
          const zeros = new Int16Array(take);
          if (!pushPCM(zeros)) return false;
          samples -= take;
        }
        return true;
      };

      // exact sample estimator based on frames (for optional skip only)
      const spb = (sr / baud) * DEFAULT_STRETCH;
      const estimateSamples = (frames) => {
        let bitUnits = 0;
        for (const f of frames){
          if (f.type === 'hold') { bitUnits += (f.sec||0) * baud; continue; }
          if (f.type === 'char') { bitUnits += 1 + 5 + stopB + (f.guardBits||0); }
        }
        const est = Math.ceil(bitUnits * spb);
        return Number.isFinite(est) && est > 0 ? est : 0;
      };

      // Process items
      let used = 0;
      for (let i=0; i<picks.length; i++){
        setStatus(`Fetching ${i+1}/${picks.length}… ${picks[i].dir}/${picks[i].filename}`);
        let raw="";
        if (els.dataSource.value === 'bundled') raw = await fetchArtTextBundled(picks[i].pagePath);
        else raw = await fetchArtTextRemote(picks[i].pagePath);
        if (!raw || !raw.trim()){ stats.empties++; continue; }
        const text = normalizeText(raw);
        const frames = buildBaudotFramesFromText(text);

        const est = estimateSamples(frames);
        if (maxItemMin>0 && est>PER_ITEM_LIMIT){ stats.tooLongSkipped++; continue; }
        if (est>SEG_LIMIT){ stats.tooLongStreamed++; /* will split across files */ }

        // stream into chunks
        afskStream(frames, { baud, mark, space, stopBits: stopB, sampleRate: sr }, (i16) => { pushPCM(i16); });
        used++;

        // gap after, if not last
        if (gapSec>0 && i<picks.length-1){
          const gapSamp = Math.max(0, Math.round(sr * gapSec));
          if (!(await emitSilence(gapSamp))) break;
        }
        if (stats.stoppedOverall) break;
      }

      // finalize
      const lastUrl = flushSegment();
      if (!used){
        let msg = 'No items added.';
        msg += ` empties:${stats.empties}`;
        msg += ` skippedByPerItem:${stats.tooLongSkipped}`;
        msg += ` splitItems:${stats.tooLongStreamed}`;
        if (stats.stoppedOverall) msg += ' (hit OVERALL minutes cap)';
        msg += '. Adjust limits or count.';
        setStatus(msg);
        return;
      }

      const totalMin = (overallSamples/sr)/60;
      const note = stats.stoppedOverall ? ' · hit overall cap' : '';
      setStatus(`Ready · segments: ${stats.segments} · items: ${used} · total ~ ${totalMin.toFixed(1)} min${note}`);

    }catch(e){
      console.error(e); setStatus('Error: ' + (e.message||e));
    }finally{
      els.buildBtn.disabled = false;
    }
  });

  // ====== Self-tests ======
  function encodeWav(samples, sampleRate){ // kept for tests
    const buffer = new ArrayBuffer(44 + samples.length*2); const view = new DataView(buffer);
    const putStr=(o,s)=>{ for(let i=0;i<s.length;i++) view.setUint8(o+i, s.charCodeAt(i)); };
    putStr(0,'RIFF'); view.setUint32(4, 36 + samples.length*2, true);
    putStr(8,'WAVE'); putStr(12,'fmt '); view.setUint32(16,16,true);
    view.setUint16(20,1,true); view.setUint16(22,1,true);
    view.setUint32(24,sampleRate,true); view.setUint32(28,sampleRate*2,true);
    view.setUint16(32,2,true); view.setUint16(34,16,true);
    putStr(36,'data'); view.setUint32(40, samples.length*2, true);
    for(let i=0;i<samples.length;i++){
      const s=Math.max(-1,Math.min(1,samples[i]))*32767; view.setInt16(44+i*2, s|0, true);
    }
    return buffer;
  }

  function runTests(){
    const log=[]; const ok=(m)=>log.push('✅ '+m); const bad=(m)=>log.push('❌ '+m);
    try{
      // existing tests
      const tCRLF = normalizeText('A' + CR + LF + 'B');
      if (tCRLF.indexOf('A' + CR + LF + 'B') !== -1) ok('CRLF preserved by normalizeText'); else bad('CRLF not preserved');
      const tSlash = normalizeText('X' + String.fromCharCode(92) + 'Y');
      if (tSlash.includes('X/Y')) ok('Backslash mapped to slash'); else bad('Backslash mapping failed');
      const sample = normalizeText('~@%{}[]|^*');
      const expect = '-AO()()/-X';
      if (sample === expect) ok('Replacement map correct'); else bad('Replacement map wrong: ' + sample + ' != ' + expect);
      const allowed = new Set((printableSet + CR + LF).split(''));
      if ([...sample].every(ch => allowed.has(ch))) ok('normalizeText emits only allowed chars'); else bad('normalizeText emitted disallowed chars');
      if (BAUDOT_TABLE.LTRS['A']===0b00011) ok('BAUDOT LTRS A'); else bad('BAUDOT LTRS A wrong');
      if ('1' in BAUDOT_TABLE.FIGS) ok('BAUDOT FIGS 1 present'); else bad('BAUDOT FIGS 1 missing');
      const frames = buildBaudotFramesFromText('HI' + CR + LF);
      if (frames.length>=10) ok('Frames built'); else bad('Frames too short');
      const fNums = buildBaudotFramesFromText('12' + CR + LF);
      const sawFIGS = fNums.some(f => f.type==='char' && f.code===FIGS);
      if (sawFIGS) ok('FIGS shift emitted for digits'); else bad('FIGS shift not emitted for digits');
      const sig = (function(){
        // tiny signal for header test
        const arr = []; const twoPi=2*Math.PI; let ph=0; const inc=twoPi*100/48000; for(let i=0;i<1000;i++){ arr.push(Math.sin(ph)); ph+=inc; }
        return arr;
      })();
      const wav = encodeWav(new Float32Array(sig), 48000);
      const dv = new DataView(wav);
      const tag = String.fromCharCode(dv.getUint8(0),dv.getUint8(1),dv.getUint8(2),dv.getUint8(3));
      const wave = String.fromCharCode(dv.getUint8(8),dv.getUint8(9),dv.getUint8(10),dv.getUint8(11));
      if (tag==='RIFF' && wave==='WAVE') ok('WAV header OK'); else bad('WAV header incorrect');
      const crOnly = 'LINE1' + CR + 'LINE2' + CR; const crlf = normalizeCRLF(crOnly);
      if (crlf.endsWith('LINE2' + CR + LF)) ok('normalizeCRLF converts CR to CRLF'); else bad('normalizeCRLF did not convert CR to CRLF');
      const wav0 = encodeWav(new Float32Array(), 48000); if (wav0.byteLength === 44) ok('Zero-length WAV header is 44 bytes'); else bad('Zero-length WAV header wrong size');
      const keep = 'A' + CR + LF + 'B'; if (normalizeCRLF(keep) === keep) ok('normalizeCRLF leaves CRLF intact'); else bad('normalizeCRLF altered existing CRLF');
      const unknown = normalizeText('🙂'); if (unknown === ' ') ok('Unknown glyphs map to space'); else bad('Unknown glyph not mapped to space');
      const fmtTag = String.fromCharCode(dv.getUint8(12),dv.getUint8(13),dv.getUint8(14),dv.getUint8(15));
      const dataTag = String.fromCharCode(dv.getUint8(36),dv.getUint8(37),dv.getUint8(38),dv.getUint8(39));
      if (fmtTag==='fmt ' && dataTag==='data') ok('fmt/data chunks present'); else bad('fmt/data chunks missing');

      // new tests: header builder + streaming
      const h = makeWavHeader(48000, 48000*60);
      if (new DataView(h).getUint32(40, true) === 48000*60*2) ok('makeWavHeader data size correct'); else bad('makeWavHeader size wrong');
      let chunks = 0; const framesTest = buildBaudotFramesFromText('TEST' + CR + LF);
      afskStream(framesTest, { baud:45.45, mark:2125, space:2295, stopBits:1.5, sampleRate:48000 }, (i16)=>{ chunks++; });
      if (chunks>0) ok('afskStream emitted chunks'); else bad('afskStream emitted no chunks');
    }catch(e){ bad('Exception in tests: '+(e.message||e)); }
    els.testLog.style.display='block';
    els.testLog.textContent = log.join('\n');
  }
  els.testBtn.addEventListener('click', runTests);
})();
</script>
</body>
</html>
